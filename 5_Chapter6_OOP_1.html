<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>OOP</title>
	<script type="text/javascript">
		var obj={
			name:"Jonathan"
		};
		console.log(obj.name);//Jonathan
		Object.defineProperty(obj,"name",{
			writable:false
		})
		obj.name="Else";
		console.log(obj.name);//Jonathan

		// var person={
		// 	weight:120
		// }
		// Object.defineProperty(person,"weight",{
		// 	configurable:false
		// })
		// Object.defineProperty(person,"weight",{
		// 	configurable:true,
		// 	value:100,
		// })//TypeError: Cannot redefine property: weight

		var book={
			_year:2004,
			edition:1
		}
		Object.defineProperty(book,"year",{
			get:function(){
				return this._year;
			},
			set:function(val){
				if(val>2004){
					this._year=val;
					this.edition+=val-2004;
				}
			}
		});
		book.year=2005;//when revise the value of year, this action calls the setter and getter function, which then revise the private variable _year
		console.log(book.edition);//2

		var paper={};
		Object.defineProperties(paper,{
			_year:{
				value:2003,
			},
			_author:{
				name:"Jonathan",
			}
		})
		console.log(paper._year);
//factory mode:
		function createObj(age, name, weight, grade){
			var obj=new Object();
			obj.age=age;
			obj.name=name;
			obj.weight=weight;
			obj.grade=grade;

			return obj;
		}
		var p1=createObj(10,"Jonathan", 120, "Year 2");
		console.log(p1.grade);
		console.log(typeof p1);//object

		var a=new String("a");
		console.log(typeof a);//object, you cannot tell the type difference between p1 and a.
//constructor mode:
		function Person(age, name, weight){
			this.age=age;
			this.name=name;
			this.weight=weight;
		}
		var p2=new Person(10,"Tom",70);//当作构造函数调用
		console.log(p2.age);//10
		console.log(p2.constructor);

		Person(12,"Will",100);//当作普通函数调用
		console.log(window.age);//12

		var p3=new Object();//另一个对象的作用域调用
		Person.call(p3,14,"Jessy",80);
		console.log(p3.age);//14

		console.log(Person.prototype);//构造函数Person通过prototype指向它的原型。
		console.log(p2.constructor);//对象p2通过constructor指向它的构造函数Person
		console.log(Person.prototype.constructor);//又指回了Person.

		console.log(Person.prototype.isPrototypeOf(p2));//true
		console.log(Object.getPrototypeOf(p2)==Person.prototype);//true;
		console.log(Object.keys(p2));//["age", "name", "weight"]
//Prototype Define
		function Video(){
			Video.prototype{
				_year:2010,
				_name:"Forever Love",
				_Singer:"Jonathan",
				_Price:120,
				constructor:Video;//防止用instanceOf的时候无法判断是谁创建的实例
			}
			
		}
		Object.defineProperty(Video.prototype,"constructor"{
			enumerable:false,
			value:Person,
		})//因为修改了原型中constructor属性，所以重新将enumerable属性设置回false
	</script>
</head>
<body>
	
</body>
</html>